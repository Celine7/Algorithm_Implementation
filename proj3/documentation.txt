Haoyue Cui(hac113)CS1501 proj3	I use DLB trie to assist indexable priority queue to ensure efficiency. There are several classes and I will explain them accordingly. ---------------------Car.java-----------------------This class is used to store data about cars to buy. There are VIN, make, model, price, mileage and color. I also add some kinds of indexes for easily accessing car object in PQ. And I also rewrite the toString() method to print out info about car easily. ---------------------VINDLB.java--------------------------This class works as the symbol table for all cars. It will store the 17-digit VIN using a DLB trie. It contains an inner class CarNode, which contains four attributes: child, neighbor, value, and car. “Value” will store the char of each VIN character. “neighbor” is the CarNode object, “child” will be a CarNode object and car will be Car object. This car attribute will work in the terminal node. I use “$” as the termination for the VIN and also, I store the Car object in this node. The insert() function will perform basically 17 traversals since formal VINs are 17 fixed characters long. In this case, the average runtime is O(17), so, the runtime is O(1) asymptotically. The exists() function is the same as insert function. It is O(1) asymptotically. And this function will return whether if this VIN number exists. This is useful for removing or updating a car. And also, I make a public variable theCar as a Car object to store the useful information and thus it could be used by CarTracker.java. The remove() function is similar with the exist function. It will traverse to the end of the trie and set the Car attribute of the last node to null. In this case, this car object is no long there but the trie will still be there. When doing other things, the program will check if car is null, so this will not affect others, for example, retrieving the lowest priced car. And if it inserts the same VIN number again, it will do the same thing, traverse 17 times, and reset the car object in the last node, So, asymptotically, runtime is O(1).For memory assumption, DLB saves a lot of memory compare with R-way trie since VIN has only 17 characters and when first adding, the trie is really sparse. It only takes 17n space if there are n car objects. ---------------------CarPQ.java--------------------------This is the class for pq structure. It is a min-heap created through array. This saves space since I don’t need to create node for each car. As discussed, the root index will be 1 (start at position 1.) The left child is at index i*2, and right child is at index i*2+1. For example, at index 4, left child is at index 8 and right child is at index 9. Then CarPQ contains variable int n to record the size of the pq. And also, it has char variable “mode” which is used to tell whether mileage pq or price pq and a boolean variable specialHeap to indicate whether the CarPQ object is for all cars or for special make and model cars. I initialize the pq to 15 since there are 14 cars in car.txt and it will be a 4-level tree. Initializing it too big will cost memory assumption so 15 will be great. For resize() method, I double the size when there are more cars being added. In this case, resizing is O(n) because it requires to copy n cars to a new array. (But since resizing is not normally common, it only happens few times when inserting, so in average case, resize() method will not be called. So, saving memory place prioritizes.)For insert() function, I will insert new car object at the end of pq and then swims up to its appropriate location. The swim() function requires O(logN) runtime, since we perform pq as a binary tree, so the runtime should be the height of binary tree, which is O(logN). For getMin() function, it is O(1) since it is a min heap and it should be the object at index 1.For update() function, since a car’s price or mileage might change and might affect the position in the pq, so we must swim car up and then sink it down. Both of the function takes O(logN), so runtime should be 2*O(logN). Thus, runtime is O(logN) asymptotically. For remove() function, it first access the correct object to be removed which is O(1) and swap it with the last object, which is O(1) still. Then remove that car object. But the car object we swapped with should be in wrong location. Thus, swims up and sinks down. So, the runtime is O(logN). There are some functions are obtained from Dr. Garrison’s website. Swim() and sink() are O(logN) as discussed before. The greater() and exch() functions are both O(1) since they are single comparison or single swap. The setSpecialHeapIndex() is O(1) since it only set the index of a pq. ---------------------PQDLB.java--------------------------There is an inner class called PQNode, it contains child, neighbor, value, pq. Child and neighbor are PQNode objects and value is char. Pq is an CarPQ object always stored at termination node. This class is only used for special pq. I create another DLB that allows me to traverse make and model in a trie. I use the format “make@model” for a specific make and model. @ is used to separate make and model to avoid confusion with where make ends. Also this does not impact runtime, make and model should be split. And like VINDLB, I still store the CarPQ object at the termination node. The insert() function is O(w) where w is the length of make@model string. So, asymptotically, it should be O(1) since w is always constant and could not be very long. And the getPQ() function is also O(w) where w is the length of make@model string because it need to go until the termination node to get the carPQ and traversing a word of length w is O(w). Asymptotically, it should be O(1). And since there are only few make@model, so using DLB trie saves memory in contrast with R-way trie. It only takes O(w*n) where w is the length of make@model string and n is the number of special make and model added here. ---------------------CarPQHeap.java--------------------------This is the class to solve solutions for all priority queues. It has four PQs: prices, mileages, sprices and smileages. Prices is a min-heap pq for prices of all cars and mileages is a min-heap for mileages of all cars. For special specific kind of make and model cars, I create PQDLB object for specialmileagesPQ and specialpricesPQ. I have explained PQDLB class before. This class is performed on pq and is being called by CarTracker.java many times. For insert() method, car is inserted into all four PQs. Inserting into CarPQ is O(logN) and there has been called twice. Function getPQ() requires O(w) and check whether if it is null is O(w) for inserting PQDLB. And then inserting in CarPQ is O(logN) as stated earlier. So, for two special make and model, runtime should be 2*O(logN) + 4*O(w). And together, it is 4* O(logN) + 4*O(w). Since O(w) is really small constant, so the asymptotic runtime is O(logN).For getLowestPrice(), getLowestMileage(), runtime is O(1). For getLowestSpecialPrice() and getLowestSpecialMileage(), runtime is O(w) + O(1) where O(w) is getting CarPQ. O(1) asymptotically.For update() function, CarPQ update() is O(logN), and getting special make and model is O(w). Similar as remove() function, asymptotically, runtime should be O(logN).For remove() function, to get each index, runtime is O(1). And remove() function in CarPQ is O(logN). Getting the special pq is O(w). So, in total, runtime is 4*O(logN) + 2*O(w). O(w) is small so asymptotically, runtime is O(logN).---------------------CarTracker.java--------------------------All in all, I will perform the total runtime.For add_car (), first check if the VIN already exists, if so, give out explanation and return, O(1). Then it called insert() in VINDLB, O(1). Then it called insert() in CarPQHeap, O(logN). Overall, O(logN).For update_car (), it called exists() in VINDLB, O(1) and called update() in CarPQHeap, O(logN). Overall, O(logN).For remove_car (), it called exists() in VINDLB, O(1) and called remove() in VINDLB(), O(1) and called remove in CarPQHeap, O(logN). Overall, O(logN).For get_lowest_price_car(), it called getLowestPrice() in CarPQHeap, O(1).For get_lowest_mileage_car(), it called getLowestMileage() in CarPQHeap, O(1).For get_lowest_price_car_by_make_and_model(), it called getLowestSpecialPrice(), O(w) + O(1) which is O(1) asymptotically.For get_lowest_mileage_car_by_make_and_model(), it called getLowestSpecialMileage, O(w) + O(1) which is O(1) asymptotically.For memory consumption, using DLB structure would save a lot of memory since no useless nodes are created. Instead of R-way trie, DLB is good for sparse keys. Also, DLB trie does not have a limitation of cars. So, we can add as many cars as possible.